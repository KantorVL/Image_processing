# -*- coding: utf-8 -*-
"""home_work3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dm3UO6eXJ_B2cMP2APEzIv-x2L1I3t3n

# Image Processing Assignment 3: Binary images

Before we start, please put your names and IDs in following format

: Firstname LASTNAME, #00000000   //   (e.g.) Dana LEVI, #12345678

**Your Answer:**   
Xxxxx XXXXX, #nnnnnn

In this exercise, you will implement **Binary Images** algorithms.

Methods: as explained in class.

Notes:
*   Write your code in the dedicated areas (TODO blocks). You can add helper functions.
*   Submission email should include a link to the Colab submission notebook located on your Google Drive with Commenter access right to nev1958a@gmail.com
*   The solution notebook should be able to be run (‘Run all’) with no errors.
In case of errors, the submission will be disqualified.
*   The grade will depend on correct performance on several grayscale images and on clean programming and documentation.
*   Do not forget to add the Names and Student I.D. at the top of the notebook.
*   All images are given as 2-dimensional matrices of type `float`, with values in the range [0..1].
*   Pay Attention! In the following functions, the returned images must be the same size as the original Images!

Please implement the following functions:
1. Write the `tag_connected_components` function which finds the connected components in a binary image and returns a matrix with the same size in which each connected component is tagged with a different label. The tags should be sequential.
2. Write the `skeletonizeImage` function which skeletonizes objects in a given binary image and returns the new binary image.

**Note** In these images, **1** represents the object, and **0** (black) represents the background.

## Setup Code
Before getting started, we need to run some boilerplate code to set up our environment. You will need to rerun this setup code each time you start the notebook.
"""

import os
import requests
from io import BytesIO
import numpy as np
import matplotlib.pyplot as plt
import PIL

GITHUB_PATH = 'https://raw.githubusercontent.com/dnevo/ImageProcessing/main/images/'

def read_file(file_name:str, file_path:str=GITHUB_PATH) -> np.ndarray:
    '''
    Accept an image file name (defaulty located in GitHub) and return the image
    in a numpy array.

    Args:
        file_name: the file name
        file_path: the file path.. Default value is Doron's Github repo.

    Returns:
        the image converted into a Numpy array.
    '''
    file_path = os.path.join(file_path, file_name)
    response = requests.get(file_path)
    fp = BytesIO(response.content)

    img_pil = PIL.Image.open(fp)
    return np.array(img_pil, dtype='int16')

def pretty_print(img):
    ''' pretty printing of binary imagees and connected components - by
    replacing zeros with whitespaces.
    Args:
        img: image in float format (range: 0..1) - the source binary image
        file_path: the file path.. Default value is Doron's Github repo.

    Returns:
        the image converted into a Numpy array.
    '''
    for r in range(img.shape[0]):
        l = [str(img[r,c].astype(np.int16)) if img[r,c]>0 else ' ' for c in range(img.shape[1])]
        print(''.join(map(str, l)))

def plot_images(img1:np.array, img2:np.array):
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(14, 6))
    axes[0].imshow(img1,  cmap='gray')
    axes[1].imshow(img2,  cmap='gray')

"""## `tag_connected_components`"""

def tag_connected_components(img: np.array) -> np.array:

    xMax, yMax = img.shape
    img_new = np.zeros((xMax, yMax), dtype=int)
    count = 0
    stack = []
    for i in range(xMax):
        for j in range(yMax):
            if img[i][j] == 1 and img_new[i][j] == 0:
                count+=1
                stack.append((i, j))
                while stack:
                    x, y=stack.pop()
                    if img_new[x][y] == 0:
                        img_new[x][y]=count
                        for dx in [-1,0,1]:
                            for dy in [-1,0,1]:
                                if 0<=x+dx<xMax and 0<=y+dy<yMax and img[x+dx][y+dy] == 1:
                                    stack.append((x+dx,y+dy))

    return img_new

img = np.array([[0,0,0,0,0,0,0,0,0],
       [0,1,0,0,0,1,0,0,0],
       [0,1,0,1,0,1,0,1,0],
       [0,1,0,1,0,1,0,1,0],
       [0,1,1,1,1,1,0,1,0],
       [0,0,0,0,0,0,0,1,0],
       [0,0,0,0,1,1,1,1,0],
       [0,0,0,0,0,0,0,0,0]])
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

img = read_file('binary1.tiff') / 255
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

img = read_file('binary2.tiff') / 255
img_n = tag_connected_components(img)
plot_images(img, img_n)

pretty_print(img_n)

"""## `skeletonizeImage `"""

def get_min (img: np.array,x,y):
  xMax, yMax = img.shape
  min=img[x][y]
  for dx, dy in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
        if 0 <= x + dx < xMax and 0 <= y + dy < yMax:
            if img[x+dx][y+dy] < min:
                min = img[x+dx][y+dy]
  return min
def get_max (img: np.array,x,y):
  xMax, yMax = img.shape
  max=img[x][y]
  for dx, dy in [(-1, 0), (0, 1), (0, -1), (1, 0)]:
        if 0 <= x + dx < xMax and 0 <= y + dy < yMax:
            if img[x+dx][y+dy] > max:
                max = img[x+dx][y+dy]
  return max


def skeletonizeImage (img_n: np.array) -> np.array:
  img=img_n.copy()
  xMax, yMax = img.shape
  img_copy=np.zeros_like(img)
  while not np.array_equal(img, img_copy):
    img_copy=img.copy()
    for i in range(xMax):
      for j in range(yMax):
        if img_copy[i][j] == get_min(img_copy,i,j) and img_copy[i][j]:
          img[i][j]+=1
  img_copy=np.zeros_like(img)
  for i in range(xMax):
      for j in range(yMax):
        if img[i][j] and img[i][j] == get_max(img,i,j):
          img_copy[i][j]=1

  return img_copy*255

img = np.array([[0,0,0,0,0,0,0,0,0],
                [0,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,0],
                [0,1,1,1,1,1,1,1,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,1,1,1,0,0,0],
                [0,0,0,0,0,0,0,0,0]])
img_new = skeletonizeImage(img)
plot_images(img, img_new)

pretty_print(img_new)

img = read_file('binary1.tiff') / 255
img_b = skeletonizeImage(img)
plot_images(img, img_b)

img = read_file('binary2.tiff') / 255
img_n = skeletonizeImage(img)
plot_images(img, img_n)

print(img_n)